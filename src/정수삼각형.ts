function solution(triangle: number[][]): number {
	// 삼각형의 높이
	const n = triangle.length;

	// 아래층부터 위로 올라가며 최댓값 계산
	for (let i = n - 2; i >= 0; i--) {
			for (let j = 0; j < triangle[i].length; j++) {
					// 현재 위치의 값을 아래층의 두 값 중 큰 값과 합산하여 갱신
					triangle[i][j] += Math.max(triangle[i + 1][j], triangle[i + 1][j + 1]);
			}
	}

	// 최종적으로 triangle[0][0]에 최대 합이 저장됨
	return triangle[0][0];

}

// 테스트 실행
console.log(solution([[7], [3, 8], [8, 1, 0], [2, 7, 4, 4], [4, 5, 2, 6, 5]])); // 출력: 30

/*
✨ keypoint : 동적 프로그래밍(Dynamic Programming)
	1. 최적 부분 구조
	2. 중복 계산을 피할 수 있음
	3. 기존 배열을 직접 갱신함으로 '메모리 효율적'
	4. '시간 복잡도 최적화'
		- 위 -> 아래 방향의 계산은 각 경로를 모두 탐색해야함.
		- 아래 -> 위 방향의 계산은 각 층을 한번 씩만 순회 -< 'O(n2)'

*/


// 풀이설명 


// 	[0][0]     		 7
// 								/ \
// 	[1][0]   		 3   8   [1][1]
// 							/ \ / \
//   [2][0]  	 8   1   0   [2][2]
// 						/ \ / \ / \
// 	[3][0]   2   7   4   4   [3][3]
// 					/ \ / \ / \ / \
//   [4][0] 4   5   2   6   5   [4][4]


// 	계산 과정

// 1. 초기화
// 삼각형의 가장 아래층부터 시작하여 위로 올라가면서 각 위치에서의 최댓값을 계산합니다.
// 이때, 아래층의 두 가지 선택지 중 더 큰 값을 현재 위치의 값에 더해 나갑니다.

// 2. 가장 아래층 (4번째 행)
// 가장 아래층은 그대로 사용합니다.

// triangle[4] = [4, 5, 2, 6, 5]

// 3. 3번째 행에서 최댓값 계산
// 행 인덱스 i = 3
// 각 위치에서 아래 두 값 중 더 큰 값을 더합니다.

// `triangle[3][0] 계산:`
// 현재 값: triangle[3][0] = 2
// 아래 왼쪽 값: triangle[4][0] = 4
// 아래 오른쪽 값: triangle[4][1] = 5
// 최대값: max(4, 5) = 5
// 갱신: triangle[3][0] = 2 + 5 = 7

// `triangle[3][1] 계산:`
// 현재 값: triangle[3][1] = 7
// 아래 왼쪽 값: triangle[4][1] = 5
// 아래 오른쪽 값: triangle[4][2] = 2
// 최대값: max(5, 2) = 5
// 갱신: triangle[3][1] = 7 + 5 = 12

// `triangle[3][2] 계산:`
// 현재 값: triangle[3][2] = 4
// 아래 왼쪽 값: triangle[4][2] = 2
// 아래 오른쪽 값: triangle[4][3] = 6
// 최대값: max(2, 6) = 6
// 갱신: triangle[3][2] = 4 + 6 = 10

// `triangle[3][3] 계산:`
// 현재 값: triangle[3][3] = 4
// 아래 왼쪽 값: triangle[4][3] = 6
// 아래 오른쪽 값: triangle[4][4] = 5
// 최대값: max(6, 5) = 6
// 갱신: triangle[3][3] = 4 + 6 = 10
// 갱신된 3번째 행: 


// triangle[3] = [7, 12, 10, 10]

// 4. 2번째 행에서 최댓값 계산
// 행 인덱스 i = 2


// `triangle[2][0] 계산:`
// 현재 값: triangle[2][0] = 8
// 아래 왼쪽 값: triangle[3][0] = 7
// 아래 오른쪽 값: triangle[3][1] = 12
// 최대값: max(7, 12) = 12
// 갱신: triangle[2][0] = 8 + 12 = 20

// `triangle[2][1] 계산:`
// 현재 값: triangle[2][1] = 1
// 아래 왼쪽 값: triangle[3][1] = 12
// 아래 오른쪽 값: triangle[3][2] = 10
// 최대값: max(12, 10) = 12
// 갱신: triangle[2][1] = 1 + 12 = 13

// `triangle[2][2] 계산:`
// 현재 값: triangle[2][2] = 0
// 아래 왼쪽 값: triangle[3][2] = 10
// 아래 오른쪽 값: triangle[3][3] = 10
// 최대값: max(10, 10) = 10
// 갱신: triangle[2][2] = 0 + 10 = 10
// 갱신된 2번째 행: triangle[2] = [20, 13, 10]

// 5. 1번째 행에서 최댓값 계산
// 행 인덱스 i = 1


// `triangle[1][0] 계산:`
// 현재 값: triangle[1][0] = 3
// 아래 왼쪽 값: triangle[2][0] = 20
// 아래 오른쪽 값: triangle[2][1] = 13
// 최대값: max(20, 13) = 20
// 갱신: triangle[1][0] = 3 + 20 = 23

// `triangle[1][1] 계산:`
// 현재 값: triangle[1][1] = 8
// 아래 왼쪽 값: triangle[2][1] = 13
// 아래 오른쪽 값: triangle[2][2] = 10
// 최대값: max(13, 10) = 13
// 갱신: triangle[1][1] = 8 + 13 = 21
// 갱신된 1번째 행: triangle[1] = [23, 21]

// 6. 꼭대기에서 최댓값 계산
// 행 인덱스 i = 0


// `triangle[0][0] 계산:`
// 현재 값: triangle[0][0] = 7
// 아래 왼쪽 값: triangle[1][0] = 23
// 아래 오른쪽 값: triangle[1][1] = 21
// 최대값: max(23, 21) = 23
// 갱신: triangle[0][0] = 7 + 23 = 30
// 갱신된 꼭대기: triangle[0] = [30]