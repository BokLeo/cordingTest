/*
당신은 폰켓몬을 잡기 위한 여행을 떠났고, 최대한 다양한 종류의 폰켓몬을 선택하려고 합니다.
당신에게는 N마리의 폰켓몬이 있고, N/2마리만 선택할 수 있습니다. 
이때, 가장 많은 종류의 폰켓몬을 선택할 수 있도록 하는 것이 목표입니다.

✍ 입력 예시
nums = [3, 1, 2, 3]

🧾 출력 예시
2

📌 설명
위 예시에서 N = 4이므로, 2마리만 선택 가능.

가능한 선택 조합 중 [1, 2] 또는 [1, 3] 등이 있으며, 서로 다른 종류는 최대 2종류가 가능하므로 정답은 2입니다.

조건
- nums 배열의 길이는 항상 짝수이며, 1 이상 10,000 이하
- nums 배열의 각 원소는 폰켓몬의 종류 번호 (1 이상 200,000 이하)

*/

function solution(nums: number[]) {
	const length = nums.length;
	const max = length / 2;
	const newNums = new Set(nums);

	return Math.min(newNums.size, max);
}

solution([3, 1, 2, 3]);

/*
🧠 개념적으로 완벽!
- Set을 통해 중복 제거 → 폰켓몬 종류 수 파악
- Math.min(종류 수, 선택 수) 로 조건 비교
- 변수명도 의미를 잘 드러냄 (가독성 굿!)

📌 개념 정리
- Set	중복을 자동으로 제거해주는 자료구조 (실무에서도 자주 씀)
- Math.min(a, b)	두 수 중 작은 값 반환 (조건 비교 시 유용)
- 시간 복잡도	O(n) — 매우 효율적

🛠 실무 감각 연결
- 중복 제거가 필요한 상황 (ex. 카테고리 필터, 유저 중복 체크 등)에 Set은 자주 사용돼.
- 예를 들어, 쇼핑몰에서 사용자가 장바구니에 중복된 상품을 넣었을 때 → 유니크한 상품 개수 계산할 때 비슷한 로직 사용!
- Math.min() 같은 간단한 API로 조건 비교 로직을 명확하게 만들면 협업에서도 읽기 쉬움.
*/
